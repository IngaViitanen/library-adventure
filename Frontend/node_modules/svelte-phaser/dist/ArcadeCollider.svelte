<script>var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { onMount, createEventDispatcher, tick } from 'svelte';
import { toArray, findGameObjectsByName } from './util';
import { onSceneEvent } from './onSceneEvent';
import { getScene } from './getScene';
import { getGameObject } from './getGameObject';
import { getTilemap } from './getTilemap';
const dispatch = createEventDispatcher();
const parent = getGameObject() ||
    getTilemap();
// `with` is a reserved keyword
let _with;
export let overlapOnly = undefined;
export let allowCollision = undefined;
export { _with as with };
const scene = getScene();
const collider = overlapOnly
    ? scene.physics.add.overlap([parent], createObjectsArray(scene, _with), (self, other) => dispatch('collide', { self, other }), allowCollision
        ? (self, other) => allowCollision({ self, other })
        : undefined)
    : scene.physics.add.collider([parent], createObjectsArray(scene, _with), (self, other) => dispatch('collide', { self, other }), allowCollision
        ? (self, other) => allowCollision({ self, other })
        : undefined);
onMount(() => () => collider.destroy());
// update gameobject references by string when a child is added to the scene
onSceneEvent(Phaser.Scenes.Events.ADDED_TO_SCENE, (object) => __awaiter(void 0, void 0, void 0, function* () {
    if (object.name) {
        const withStrings = toArray(_with).filter((obj) => typeof obj === 'string');
        if (withStrings.includes(object.name)) {
            // @ts-ignore
            collider.object2 = [...collider.object2, object];
        }
    }
}));
$: collider.object2 = createObjectsArray(scene, _with);
$: collider.overlapOnly = overlapOnly;
function createObjectsArray(scene, objects) {
    return toArray(objects).reduce((total, object) => {
        if (typeof object === 'string') {
            return [...total, ...findGameObjectsByName(scene, object)];
        }
        return [...total, object];
    }, []);
}
</script>
